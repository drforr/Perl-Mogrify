NAME
    Perl::ToPerl6 - Convert Perl5 source to compile under Perl6.

SYNOPSIS
        perlmogrify source.pl

DESCRIPTION
    Perl::ToPerl6 is an extensible framework for transforming Perl5 code into
    Perl6.  The framework owes a great deal to Jeffrey Thalmer and
    L<Perl::Critic>, inasmuch as the source was almost completely cribbed from
    there. Any remaining bugs are my fault, however.

    This is meant to be extenible so that others can create their own Perl5 to
    Perl6 custom transformation modules and add the to the
    L<Perl::ToPerl6::Transformer> namespace.

    The existing modules are the result of taking existing perl5 code and
    hand-munging it to Perl6 status. The original L<Perl::Critic> system remains
    in place, so you can create your own transformation profiles with custom
    .perlmogrifyrc files, and basically any other way L<Perl::Critic> allows you
    to configure the tool.

    The documentation is still basically a s/// of the original L<Perl::Critic>
    documentation, with the exception of this README. If you're brave or
    foolish, feel free to use L<Test::Perl::ToPerl6> to translate your code as
    part of your test suite or source code control platform, but caveat emptor.

WHAT DOES IT DO

    As of the initial release, it contains transformers for:
    
        Basic data types (integers, floats, strings)
            Binary, Octal and Hexadecimal integer
            Floating-point trailing decimal
            Here-docs
            Interpolated values ("${x}", "$x-foo" etc.)
            Interpolated case shifting ("\lfoo", "\LFOO\E" etc.)
        Builtins
            'print $fh "text", $x'
        Q types
            qw(), qr(), qx()
        Conditional constructs ('if', 'elsif', 'unless', 'when')
        Looping constructs ('for', 'foreach', 'while', 'until')
            'for(1;2;3)'
            'for $x (@y)'
            Transformation of C-style loops
        First-order operators
            'map {} @foo', 'grep !2 @a'
        Core operators ('->', '.', '<<', '>>', '!' etc.)
        Package declarations ('package My::Package;', 'package My::Package {}')
        Package usage ('use Foo::Bar')
        Pragmas ('utf8', 'warnings', 'overload' etc.)
        Dereferencing ('%{ $foo }', '%$foo' etc.)
        Hashes ('$foo{a}', "$foo{'a'}" etc.)
        Sigils ('$x', '$a[1]', '@a', '%a{a,b}' etc.)
        Special variables ('@ARGV', '@+', '%ENV' etc.)
        Special literals ('__END__', '__PACKAGE__', '__FILE__' etc.)

CONFIGURATION

    Please read Perl::Critic>s documentation for more information. Quite a bit
    of this will be invalid soon as while the infrastructure it provides is
    wonderful, some of the indiviual flags and data types Perl::Critic uses
    aren't really appropriate for this.

THE TRANSFORMERS

    Please see the Perl::ToPerl6::Transformer:: namespace for a full listing of
    the core modules that come with Perl::ToPerl6. The core modules are all
    documented, albeit in a minimal sense. 'perlmogrify -doc PATTERN' might
    still work and should bring up documentation for the appropriate module.

    If other people do write transformer modules, I might be tempted to add
    support for a L<Perl::ToPerl6::TransformerX> namespace, but we'll discuss
    that issue if it ever comes up.

TRANSFORMER THEMES

    This is a completely unused feature for the moment, it may come into use
    once I figure out how to properly integrate it.

BENDING THE RULES
    I don't really see a point to this at the moment unless you need to retain
    a specific module or some tricky bit of syntax that fails to convert, but
    the '## no mogrify' line marker may work for your needs, as it's a holdover
    from this module's genesis as Perl::Critic.

THE Perl::ToPerl6 PHILOSOPHY

    For the moment, there is no facility for defining the order that
    transformers are run in, so each individual module cannot rely on other
    transformations being done. So far during development this hasn't been a
    problem, but I do make allowances at certain points, for instance there
    are two separate transformation modules for the C<for> loop, and the last
    one to run assumes that nothing has been run.

    There is a Perl::ToPerl6::Utils namespace where utilities for transformers
    will reside, such as determining the style of a 'for' loop. This was a pain
    and probably already exists on CPAN but I'm already pulling in quite a few
    dependencies for this module as it is.

EXTENDING THE MOGRIFIER
    The simplest place to start is decide on a transformation you want to
    accomplish, say, C<qw(a b c)> to a more Perl6ish style, such as
    C< <a b c> >. Looking through the existing Transformer libraries, you'll
    see an Arrays/FormatArrayQws file that adds whitespace following 'qw'.

    This means that the module already searches for 'qw()' constructs in a
    perl5 document, so that's a good place to start modifying.

    Create a new Transformer:: module, say, L<Transformer::Arrays::Perl6Style>
    and copy L<t/Arrays/FormatArrayQws.run> to L<t/Arrays/Perl6Style.run>.

    You'll need to modify the C<package> declaration of course, an probably
    want to update the documentation. Now, pay attemtion to the new
    L<t/Arrays/Perl6Style.run> file. It's a pretty simple format, put a sample
    of what you're looking for, say C<qw(a b c)> above the '#-->' line, and
    what you want it to look like, say C< <a b c> >, below the line.
    
    At this point it's worth pointing out some ideas that'll let you test
    faster and more accurately. L<PPI> has generally two kinds of tree-walking
    functions, those that are sensitive to whitespace and those that are
    insensitive. Most of the time you want to use the insensitive versions,
    which are prefixed by 's' as in C<schild(0)> vs. C<child(0)>.

    A good habit to form is always adding whitespace (except where the
    whitespace itself is the point) to your test lines, for instance preferring
    C<for $x ( @x )> to C<for$x(@x)>. It's easier to read, and as a bonus if
    you do that, when you forget to use C<snext_sibling> instead of
    C<next_sibling> you'll find your bug faster.

    Something else to keep in mind as you're creating tests is that the
    expression you're looking for won't always begin at the start of a
    L<PPI::Statement>. As a trivial example, C<$x++> may occur at the end of
    a long statement, such as C<1 if $x++>. So, when creating your test suites
    be sure that at least a few of your test cases don't begin precisely at
    the statement boundary.

    Transformer Layout

    You'll pay the most atention to two methods: C<applies_to> and
    C<transform>. C<transform> does the dirty work, and C<applies_to> tells
    the transformer what it's suppoed to run on.

    It's tempting to cheat, and just make C<applies_to> tell the processor to
    look for C<PPI::Document>, which applies your transformer to the whole
    document. And in a few cases, of course, you'll have to do this.

    But most of the time it's easier to use one of the two forms to tell
    the processor exactly what to look for, so your transformer can explicitly
    target the construct you're after.

    So, try in general to supply the most restrictive definition of the L<PPI>
    term you can to C<applies_to>, and I encourage you to look in
    L<Perl::ToPerl6::Utils::PPI> to find some premade matchers, for tokens
    and such.

    That way, when C<transform> runs, you can assume that the C<$elem> argument
    is exactly what you're looking for, and you don't need to do any sort of
    checking in the function, but can step directly in to running C<content>
    to see what the node looks like, and C<set_content> to change the node's
    content.

    Philosophy

    Blatantly mimcking the UNIX philosophy in general (at least until recently)
    transformers do one small change, and pass the changed result down to the
    next transformer in line.

    Just to keep the source tree clean and reasonably Perlish, I try to create
    new tokens for whitespace and such where it's practical. Please also note
    that at some points I'm forced to violate PPI encapsulation, for instance
    changing brace styles or a heredoc's marker.

    Feel free to send me a pull request on GitHub if you've developed a module
    and want it integrated.

PREREQUISITES
    Perl::ToPerl6 requires the following modules:

    B::Keywords

    Config::Tiny

    Exception::Class

    File::HomeDir

    File::Spec

    File::Spec::Unix

    File::Which

    IO::String

    List::MoreUtils

    List::Util

    Module::Pluggable

    PPI

    Pod::PlainText

    Pod::Select

    Pod::Usage

    Readonly

    Scalar::Util

    String::Format

    Task::Weaken

    Term::ANSIColor

    Text::ParseWords

    version

CONTACTING THE DEVELOPMENT TEAM

    Currently the development team is just me, [mailto:drforr@pobox.com] or send
    me a pull request for the appropriate module on GitHUb. I'll keep an eye out
    for requests and integrate them as they come in, or within a reasonable time
    frame.

    You can also catch me on IRC at either [irc://irc.perl.org/#perl] or
    [irc://irc.freenode.net/#perl], and follow me on Twitter at
    [https://twitter.com/drforr]

SEE ALSO
    Please note this is *mostly* based on Perl::Critic code, so please see that
    module if you have questions about why something was implemented. Also most
    of the documentation still is from that module, and will be replaced on a
    purely ad-hoc basis.

BUGS
    Feel free to submit bugs via either RT or GitHub. GitHub and personal email
    gets checked more frequently, or just bounce me a note on IRC if I happen to
    be active.

CREDITS

    Jeffrey Thalhammer - For creating the framework I'm shamelessly ripping off, so I don't have to create an entire plugin architecture.

    Adam Kennedy - For creating PPI, the heart and soul of Perl::ToPerl6.

    Damian Conway - For writing Perl Best Practices, finally :)

    Chris Dolan - For contributing the best features and Transformer modules.

    Andy Lester - Wise sage and master of all-things-testing.

    Elliot Shank - The self-proclaimed quality freak.

    Giuseppe Maxia - For all the great ideas and positive encouragement.

AUTHOR
    Jeffrey Goff <drforr@pobox.com>

AUTHOR EMERITUS
    Jeffrey Ryan Thalhammer <jeff@imaginative-software.com>

COPYRIGHT
    Copyright (c) 2015 Jeffrey Goff <drforr@pobox.com>

    This program is free software; you can redistribute it and/or modify it
    under the same terms as Perl itself. The full text of this license can
    be found in the LICENSE file included with this module.

